---
title: "<br>Image Segmentation"
author: "Derek Wayne"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    df_print: paged
    highlight: tango
    css: style.css
    includes:
      before_body: header.html
      after_body: footer.html
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), 'index.html')) })
subtitle: Applications to Neuroimaging Analysis
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The methods of [cluster analysis](https://derekwayne.github.io/clustering/) can be applied to the process of segmenting an image by assigning to each pixel a label indicating some form of shared characteristic such as boundaries or colours. The goal is to identify important regions of an image where each segment belongs to one particular surface, object, etc. There are applications in image processing/compression, object recognition, database searching, and edge detection for feature extraction.

The purpose of this project is to go over in detail the process of segmenting an image. The image involved will determine which frameworks are most effective in achieving a good segmentation of the image. We will look at the K-means algorithm, which performs well when objects in an image are well separated in a colour space; and we will look at a more advanced procedure for the task of segmenting soft tissues present in medical images of the brain.

```{r include=FALSE}
library(imager)
library(ggplot2)
library(dplyr)
library(kableExtra)
```
The [Imager](https://cran.r-project.org/web/packages/imager/index.html) package cotains some example images to work with. We will import the parrots file as it can highlight the ease with which algorithms can segment within a 3 dimensional color space (*RGB*).
```{r}
file <- system.file('extdata/parrots.png',package='imager')
parrots <- load.image(file)
parrots
```
The data is stored as a `cimg` class, which behaves identically as an array. For purposes of plotting with the ggplot2 package, which requires data be stored as a dataframe we convert the default cmig object. 
```{r}
parrots_df <- as.data.frame(parrots,wide="c") %>% # wide format with channels as columns
  mutate(rgb.val=rgb(c.1,c.2,c.3)) 
names <- c("x", "y", "R", "G", "B", "rgb.val")
colnames(parrots_df) <- names
```
```{r echo=FALSE}
kable(head(parrots_df, 3)) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r echo=FALSE}
# ggplot theme to be used
plotTheme <- function() {
  theme(
    panel.background = element_rect(
      size = 1,
      colour = "black",
      fill = "white"),
    axis.ticks = element_line(
      size = 2),
    panel.grid.major = element_line(
      colour = "gray80",
      linetype = "dotted"),
    panel.grid.minor = element_line(
      colour = "gray90",
      linetype = "dashed"),
    axis.title.x = element_text(
      size = rel(1.2)),
    axis.title.y = element_text(
      size = rel(1.2)),
    plot.title = element_text(
      size = 20,
      vjust = 1.5)
  )
}
```
```{r echo=FALSE}
# Plot the image
ggplot(data = parrots_df, aes(x = x, y = y)) + 
  geom_point(colour = rgb(parrots_df[c("R", "G", "B")])) +
  labs(title = "Original Image: Parrots") +
  xlab("x") +
  ylab("y") +
  scale_y_reverse() +
  plotTheme()
```

The image has a wide colour palette that we hope will serve as the basis of our segmentation. Without using spacial information, each pixel has a corresponding 3-dimentional vector of color channels -- red, green, and blue. The K-means algorithm should perform well here since the colours help to differentiate the parrots from each other and the background (i.e. good separation).


# K-Means Clustering

The K-means method is a simple solution to the problem of finding clusters centers that minimize the variance within each cluster. Each cluster in our problem refers to a specific colour value. Consequently, a pixel is considered to be "like" another if they are near each other in the colour space. Euclidean distance will define the notion of "nearness". K-means requires that we specify the number of clusters a-priori. Determining the optimal number of clusters depends on the problem at hand. The goal of segmenting an image is only to find the clusters/colours that we deem most important in separating the objects. The salient colours in the parrots image are red, green, turquoise, yellow, white, and black. So we might choose the number of clusters to be around 6-8. Next, we need to choose a method of initalization for the pixel centers. The K-means++ algorithm is a seeding procedure for the centers which results in an improvement of the final error and a decrease in computation time. Intuitively, initial centers should be chosen such that they are not too close together. This idea is implemented in the function below.

```{r}
# rows are centers
centers <- function(x, k) {
  x <- as.matrix(x)
  center.mat <- matrix(0, nrow=k,ncol=ncol(x))
  center.init <- x[sample(nrow(x), size=1), ]
  center.mat[1, ] <- center.init
  for (i in 2:k) {
    e.dist <- sqrt(rowSums((x-center.init)^2)) # compute euclidean distance
    probs <- e.dist^2 / (max(e.dist)^2 + 1) # weighted probability
    center.new <- x[sample(nrow(x), size=1, prob=probs), ]
    
    center.mat[i, ] <- center.new
  }
  center.mat
}
```

Although this initialization process does require some computational effort, the K-means procedure should converge more quickly on average. Now we will use this in conjunction with R's built in `kmeans` function.

```{r}
kmpp <- function(x, k) {
  centers <- centers(x, k)
  kmeans(x, centers)
}
```


```{r}
cl <- kmpp(parrots_df[, c("R", "G", "B")], k=8)
kColours <- rgb(cl$centers[cl$cluster, ])
```

```{r echo=FALSE, fig.show="hold", out.width="50%"}
cl2 <- kmpp(parrots_df[, c("R", "G", "B")], k=6)
k2colours <- rgb(cl2$centers[cl2$cluster, ])
ggplot(data = parrots_df, aes(x = x, y = y)) + 
  geom_point(colour = k2colours) +
  labs(title = paste("k-Means Clustering of", 6, "Colours")) +
  xlab("x") +
  ylab("y") + 
  scale_y_reverse() +
  plotTheme()

ggplot(data = parrots_df, aes(x = x, y = y)) + 
  geom_point(colour = kColours) +
  labs(title = paste("k-Means Clustering of", 8, "Colours")) +
  xlab("x") +
  ylab("y") + 
  scale_y_reverse() +
  plotTheme()
```

# Application to Neuroimaging

A magnetic resonance imaging (MRI) scan of the brain presents an important application of image-based segmentation. The three main tissue classes that are normally segmentated in a scan are white matter (WM), gray matter (GM), and cerebrospinal fluid (CSF). Facilitating segmentation requires high contrasts between these tissue types. To generate improved tissue contrasts requires varying parameters of the pulse sequences responsible for causing the hydrogen atoms contained in the body to emit radio frequencies when subjected to a magnetic field. The contrasts achieved through MRI scans is an improvement over computed tomography. However, results still suffer from the following obstacles to segmentation

1. Electronic noise -- disturbance in the electrical signal
2. A bias field -- An unwanted artifact producing inhomogenous intensities of tissue regions
3. The partial volume effect -- overlap of tissue classes within a voxel

The paper [Segmentation of Brain MR Images Through a Hidden Markov Random Field Model and the Expectation-Maximization Algorith](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.200.3832&rep=rep1&type=pdf) by Yongyue Zhang et al. provides justification for a Hidden Markov Random Field (HMRF) model together with an Expectation Maximization (EM) method of iterative parameter updating, for a framework that effectively overcomes these difficulties in segmentation.

In this project we adopt this framework to segment a single 2-D slice taken from an MRI scan obtained from [Neuromorphometrics, Inc.](http://www.neuromorphometrics.com/?page_id=310). The success of this approach offers a means for automatic brain MR image segmentation.

## NIfTI data format

The Neuroimaging Informatics Technology Initiative (NIfTI) format is an improvement on the ANALYZE format, retaining a header/image combination of data but also allowing for storage of auxillary information inside the file. The `readMRI` function from the **mritc** package can be used to obtain an array with the appropriate image dimensions. 

```{r include=FALSE}
library(mritc)
```
```{r}
# Read in NIfTI data
# data <- readMRI("NIFTI/1103_3.nii", format="nifti")
img <- readNIfTI("NIFTI/1103_3.nii")
# See all attributes of the NIfTI object
img
```

First we need to access the data in the object. Next we want to select particular slice ranging over the z-values of the three dimensional space and visualize a transverse segment.

```{r}
data = slot(img, ".Data")
class(data)
slice = data[,,140] # where z=140
```

```{r, echo = FALSE}
slice <- as.cimg(slice)
slice_df <- as.data.frame(slice)
p <- ggplot(slice_df,aes(x,y))+geom_raster(aes(fill=value)) +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0),trans=scales::reverse_trans()) +
  scale_fill_gradient(low="black",high="white") +
  coord_fixed() +
  plotTheme() +
  theme(legend.position = "none")
p
```

## The HMRF-EM Model

*In Progress*










